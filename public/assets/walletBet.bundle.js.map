{"version":3,"file":"walletBet.bundle.js","sources":["../../src/walletBet.ts"],"sourcesContent":["// src/walletBet.ts\r\nimport { Buffer } from 'buffer';\r\nimport process from 'process';\r\nimport * as nodeCrypto from 'crypto-browserify';\r\n\r\n// Polyfills\r\n(globalThis as any).Buffer  ||= Buffer;\r\n(globalThis as any).process ||= process;\r\n(globalThis as any).__nodeCrypto = nodeCrypto;\r\n\r\nconst KEY='kk_wallet_v1', IV='kk_wallet_iv_v1';\r\n\r\n// Constants\r\nconst KIBL_GROUP_ADDR = 'nexa:tpjkhlhuazsgskkt5hyqn3d0e7l6vfvfg97cf42pprntks4x7vqqqcavzypmt';\r\nconst KIBL_TOKEN_HEX  = '656bfefce8a0885acba5c809c5afcfbfa62589417d84d54108e6bb42a6f30000';\r\nconst HOUSE_ADDRESS   = 'nexa:nqtsq5g5pvucuzm2kh92kqtxy5s3zfutq3xgnhh5src65fc3';\r\nconst KIBL_TOKEN_ID   = 'nexa:tpjkhlhuazsgskkt5hyqn3d0e7l6vfvfg97cf42pprntks4x7vqqqcavzypmt';\r\n\r\n// --- SINGLETON CACHE ---\r\nlet cachedSession: {\r\n  wallet: any;\r\n  account: any;\r\n  address: any;\r\n  network: any;\r\n  balances: any;\r\n  sdk: any;\r\n} | null = null;\r\n\r\n// --- FIX: CONNECTION LOCK ---\r\n// Prevents multiple parallel connection attempts\r\nlet connectionPromise: Promise<void> | null = null;\r\n\r\nasync function getSdk() {\r\n  return await import('nexa-wallet-sdk');\r\n}\r\n\r\n// --- NODE CONFIGURATIONS ---\r\nconst PRIVATE_NODE = {\r\n  scheme: 'wss' as const,\r\n  host: 'node.remy-dev.com', \r\n  port: 443,                 \r\n};\r\n\r\nconst PUBLIC_NODE = {\r\n  scheme: 'wss' as const,\r\n  host: 'electrum.nexa.org', \r\n  port: 20004,\r\n};\r\n\r\nasync function connectMainnet(rostrumProvider: any) {\r\n  // --- FIX: Reuse in-flight connection attempts ---\r\n  if (connectionPromise) return connectionPromise;\r\n\r\n  connectionPromise = (async () => {\r\n    try {\r\n      if (rostrumProvider.isConnected) return;\r\n\r\n      console.log('[Client] Connecting to network...');\r\n\r\n      // 1. Private Node\r\n      try {\r\n        await rostrumProvider.connect(PRIVATE_NODE);\r\n        console.log('✅ Connected to Private Node');\r\n        return;\r\n      } catch (e) {\r\n        console.warn('⚠️ Private node unreachable, switching to public backup...');\r\n      }\r\n\r\n      // 2. Public Node\r\n      try {\r\n        // --- FIX: Add a small delay to let the socket cleanup ---\r\n        await new Promise(r => setTimeout(r, 200)); \r\n        await rostrumProvider.connect(PUBLIC_NODE);\r\n        console.log('⚠️ Connected to Public Backup Node');\r\n      } catch (e) {\r\n        console.error('❌ All network nodes failed.');\r\n        throw new Error('Network connection failed. Please refresh.');\r\n      }\r\n    } finally {\r\n      // Release lock\r\n      connectionPromise = null;\r\n    }\r\n  })();\r\n\r\n  return connectionPromise;\r\n}\r\n\r\nfunction getWalletCtor(mod: any) {\r\n  return mod?.Wallet ?? mod?.default?.Wallet;\r\n}\r\n\r\nexport async function loadWallet(pass: string) {\r\n  // 1. Return Cache if valid\r\n  if (cachedSession) {\r\n    const { rostrumProvider } = cachedSession.sdk;\r\n    \r\n    // --- FIX: AGGRESSIVE HEALTH CHECK ---\r\n    // If the provider is dead, we DESTROY the cache and force a full reload.\r\n    // We do NOT try to reconnect the zombie provider.\r\n    if (!rostrumProvider.isConnected) {\r\n       console.log('[Client] Connection dropped. Destroying stale session...');\r\n       cachedSession = null; \r\n       // Fall through to \"Initial Load\" below to create a FRESH wallet/provider\r\n    } else {\r\n       return cachedSession;\r\n    }\r\n  }\r\n\r\n  // 2. Initial Load (Decrypt)\r\n  const rawB64 = localStorage.getItem(KEY);\r\n  const ivB64  = localStorage.getItem(IV);\r\n  if (!rawB64 || !ivB64) throw new Error('No local wallet. Visit Connect.');\r\n\r\n  const raw = atob(rawB64);\r\n  const ivb = atob(ivB64);\r\n  const iv  = new Uint8Array([...ivb].map(c=>c.charCodeAt(0)));\r\n  const ct  = new Uint8Array([...raw].map(c=>c.charCodeAt(0)));\r\n\r\n  const h   = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(pass));\r\n  const key = await crypto.subtle.importKey('raw', h, 'AES-GCM', false, ['decrypt']);\r\n  const pt  = await crypto.subtle.decrypt({ name:'AES-GCM', iv }, key, ct);\r\n  const { seed, net } = JSON.parse(new TextDecoder().decode(pt)); \r\n\r\n  // --- SDK + provider\r\n  const sdk = await getSdk();\r\n  \r\n  // NOTE: The Wallet constructor below creates its own provider internally.\r\n  // We don't manually create one here anymore to avoid sync issues.\r\n  \r\n  const WalletCtor = getWalletCtor(sdk);\r\n  if (!WalletCtor) throw new Error('Wallet export missing');\r\n\r\n  const wallet  = new WalletCtor(seed, net);\r\n  \r\n  // Extract the provider the wallet created\r\n  const rostrumProvider = wallet.rostrumProvider || wallet.provider;\r\n\r\n  // Connect utilizing our safe wrapper\r\n  await connectMainnet(rostrumProvider);\r\n\r\n  console.log('[Client] Initializing Wallet (Scanning UTXOs)...');\r\n  await wallet.initialize(); \r\n\r\n  const account = wallet.accountStore.getAccount('2.0');\r\n  if (!account) throw new Error('DApp account (2.0) not found.');\r\n  const address = account.getPrimaryAddressKey().address; \r\n\r\n  const nexaMinor = Number(account.balance?.confirmed || 0);\r\n  const kiblMinor = Number(account.tokenBalances?.[KIBL_GROUP_ADDR]?.confirmed || 0);\r\n\r\n  const DEC = 2;\r\n  const balances = {\r\n    kiblMinor,\r\n    kibl: (kiblMinor / 10 ** DEC),\r\n    nexaMinor,\r\n    nexa: (nexaMinor / 10 ** DEC),\r\n    tokenHex: KIBL_TOKEN_HEX,\r\n    tokenGroup: KIBL_GROUP_ADDR,\r\n  };\r\n\r\n  // 3. Save to Cache\r\n  cachedSession = { wallet, account, address, network: net, balances, sdk };\r\n  return cachedSession;\r\n}\r\n\r\nexport async function placeBet({\r\n  passphrase,\r\n  kiblAmount,   \r\n  tokenIdHex,   \r\n  feeNexa       \r\n}: {\r\n  passphrase: string; kiblAmount: number; tokenIdHex: string; feeNexa: number;\r\n}) {\r\n  if (!cachedSession && (!passphrase || passphrase.length < 8)) {\r\n     throw new Error('Password required (8+ chars).');\r\n  }\r\n  \r\n  // 1. Get Wallet (Safely handles reconnects now)\r\n  const { wallet, account, address, network } = await loadWallet(passphrase);\r\n  \r\n  console.log('[Client] Building Transaction...');\r\n\r\n  // 2. BUILD\r\n  const signedTx = await wallet.newTransaction(account)\r\n    .onNetwork('mainnet')\r\n    .sendTo(HOUSE_ADDRESS, feeNexa.toString())\r\n    .sendToToken(HOUSE_ADDRESS, kiblAmount.toString(), KIBL_TOKEN_ID)\r\n    .populate()\r\n    .sign()\r\n    .build();\r\n  \r\n  // 3. BROADCAST\r\n  const txId = await wallet.sendTransaction(signedTx);\r\n\r\n  console.log('[Client] Bet Sent! TxId:', txId);\r\n\r\n  return { txId, network, address, house: HOUSE_ADDRESS };\r\n}"],"names":["Buffer","process","rostrumProvider"],"mappings":"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"}