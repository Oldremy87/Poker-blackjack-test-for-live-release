{"version":3,"file":"walletBet.bundle.js","sources":["../../src/walletBet.ts"],"sourcesContent":["// src/walletBet.ts\r\nimport { Buffer } from 'buffer';\r\nimport process from 'process';\r\nimport * as nodeCrypto from 'crypto-browserify';\r\n(globalThis as any).Buffer  ||= Buffer;\r\n(globalThis as any).process ||= process;\r\n(globalThis as any).__nodeCrypto = nodeCrypto;\r\n\r\nconst KEY='kk_wallet_v1', IV='kk_wallet_iv_v1';\r\n\r\n// Fill these from your config / env / window:\r\nconst KIBL_GROUP_ADDR = 'nexa:tpjkhlhuazsgskkt5hyqn3d0e7l6vfvfg97cf42pprntks4x7vqqqcavzypmt';\r\nconst KIBL_TOKEN_HEX  = '656bfefce8a0885acba5c809c5afcfbfa62589417d84d54108e6bb42a6f30000';\r\n\r\nasync function getSdk() {\r\n  return await import('nexa-wallet-sdk'); // vite alias -> browser ESM build\r\n}\r\nfunction getWalletCtor(mod: any) {\r\n  return mod?.Wallet ?? mod?.default?.Wallet;\r\n}\r\nfunction toFixedFromMinor(minorBn: bigint, decimals: number): string {\r\n  const s = minorBn.toString();\r\n  if (decimals === 0) return s;\r\n  const neg = s.startsWith('-');\r\n  const digits = neg ? s.slice(1) : s;\r\n  const pad = Math.max(0, decimals - digits.length);\r\n  const left = digits.length > decimals ? digits.slice(0, -decimals) : '0';\r\n  const right = (pad ? '0'.repeat(pad) : '') + digits.slice(-decimals).padStart(decimals, '0');\r\n  return (neg ? '-' : '') + `${left}.${right}`;\r\n}\r\n\r\nexport async function loadWallet(pass: string) {\r\n  // --- decrypt local keystore\r\n  const rawB64 = localStorage.getItem(KEY);\r\n  const ivB64  = localStorage.getItem(IV);\r\n  if (!rawB64 || !ivB64) throw new Error('No local wallet. Visit Connect.');\r\n\r\n  const raw = atob(rawB64);\r\n  const ivb = atob(ivB64);\r\n  const iv  = new Uint8Array([...ivb].map(c=>c.charCodeAt(0)));\r\n  const ct  = new Uint8Array([...raw].map(c=>c.charCodeAt(0)));\r\n\r\n  const h   = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(pass));\r\n  const key = await crypto.subtle.importKey('raw', h, 'AES-GCM', false, ['decrypt']);\r\n  const pt  = await crypto.subtle.decrypt({ name:'AES-GCM', iv }, key, ct);\r\n  const { seed, net } = JSON.parse(new TextDecoder().decode(pt)); // net: 'mainnet'|'testnet'\r\n\r\n  // --- SDK + provider\r\n  const sdk = await getSdk();\r\n  const { rostrumProvider } = sdk;\r\n\r\n  // connect once (guard against duplicate connects)\r\n  try {\r\n    const host = net === 'mainnet' ? 'electrum.nexa.org' : 'testnet-electrum.nexa.org';\r\n    const port = net === 'mainnet' ? 20004 : 30004;\r\n    const scheme = 'wss';\r\n    await rostrumProvider.connect?.({ host, port, scheme });\r\n  } catch (_) {\r\n    // ignore if already connected or if connect() isn't idempotent\r\n  }\r\nconst toNum = (v: string | number | bigint): number =>\r\n  typeof v === 'bigint' ? Number(v) : typeof v === 'string' ? Number(v) : v;\r\n\r\n// NOTE: adjust DECIMALS if your minor units aren't 2 d.p.\r\nconst DECIMALS = 2;\r\nconst fromMinor = (n: number) => n / Math.pow(10, DECIMALS);\r\n\r\n  // --- wallet + account\r\n  const WalletCtor = getWalletCtor(sdk);\r\n  if (!WalletCtor) throw new Error('Wallet export missing');\r\n\r\n  const wallet  = new WalletCtor(seed, net);\r\n  await wallet.initialize();\r\n\r\n  const account = wallet.accountStore.getAccount('2.0');\r\n  if (!account) throw new Error('DApp account (2.0) not found.');\r\n  const address = account.getPrimaryAddressKey().address; \r\n  const kiblBal = await rostrumProvider.getTokensBalance(address, KIBL_TOKEN_HEX);\r\n  const nexaBal=  await rostrumProvider.getBalance (address);\r\n\r\nconst kiblMinor = toNum(kiblBal.confirmed[KIBL_TOKEN_HEX]);\r\nconst nexaMinor = toNum(nexaBal.confirmed);\r\n\r\n  const balances = {\r\n  kiblMinor,\r\n  kibl: fromMinor(kiblMinor),\r\n\r\n  nexaMinor,\r\n  nexa: fromMinor(nexaMinor),\r\n\r\n  tokenHex: KIBL_TOKEN_HEX,\r\n  tokenGroup: KIBL_GROUP_ADDR,\r\n};\r\n  return { wallet, account, address, network: net, balances };\r\n}\r\n\r\nasync function csrf() {\r\n  if ((window as any).csrfToken) return (window as any).csrfToken;\r\n  const r = await fetch('/api/csrf', { credentials:'include' });\r\n  const j = await r.json();\r\n  (window as any).csrfToken = j.csrfToken;\r\n  return j.csrfToken;\r\n}\r\n\r\nexport async function placeBet({ passphrase, kiblAmount, tokenIdHex, feeNexa }: {\r\n  passphrase: string; kiblAmount: number; tokenIdHex: string; feeNexa: number;\r\n}) {\r\n  if (!passphrase || passphrase.length < 8) throw new Error('Password required (8+ chars).');\r\n  const net = 'mainnet'\r\n  const sdk = await getSdk();\r\n  const { rostrumProvider } = sdk;\r\n\r\n  // connect once (guard against duplicate connects)\r\n  try {\r\n    const host = net === 'mainnet' ? 'electrum.nexa.org' : 'testnet-electrum.nexa.org';\r\n    const port = net === 'mainnet' ? 20004 : 30004;\r\n    const scheme = 'wss';\r\n    await rostrumProvider.connect?.({ host, port, scheme });\r\n  } catch (_) {\r\n    // ignore if already connected or if connect() isn't idempotent\r\n  }\r\n  const { wallet, account, address, network } = await loadWallet(passphrase);\r\n  const CSRF = await csrf();\r\n\r\n  const house = 'nexa:nqtsq5g5pvucuzm2kh92kqtxy5s3zfutq3xgnhh5src65fc3';  // Hardcode your house address\r\n\r\n  // Pre-check balances client-side\r\n  const kiblBal = await rostrumProvider.getTokensBalance(address, tokenIdHex);\r\n  const nexaBal = await rostrumProvider.getBalance(address);\r\n  if (Number(kiblBal.confirmed[tokenIdHex] || 0) < kiblAmount) throw new Error('Insufficient KIBL');\r\n  if (Number(nexaBal.confirmed || 0) < feeNexa) throw new Error('Insufficient NEXA');\r\n\r\n  console.log('[placeBet] Building TX client-side from', address, 'kiblAmount', kiblAmount, 'tokenIdHex', tokenIdHex, 'feeNexa', feeNexa);\r\n\r\n  // Build, populate, sign, and build hex client-side\r\n  const tx = wallet.newTransaction(account);  // Pass account if required by SDK\r\n  tx.onNetwork(network);\r\n  tx.sendTo(house, feeNexa.toString());  // NEXA to house (for fee)\r\n  tx.sendToToken(house, kiblAmount.toString(), tokenIdHex);  // Tokens to house\r\n  // tx.melt(tokenIdHex, kiblAmount.toString());  // Uncomment if burning is needed for bet commitment\r\n  await tx.populate();  // Fetches and selects UTXOs client-side\r\n  const signedTx = await tx.sign().build();  // Sign and get signed hex\r\n\r\n  console.log('[placeBet] Signed HEX len', signedTx?.length);\r\n\r\n  // Broadcast client-side\r\n  const txId = await wallet.sendTransaction(signedTx)\r\n  console.log('Transaction ID:', txId)\r\n\r\n  return { txId, network, address, house };\r\n}\r\n"],"names":["Buffer","process"],"mappings":"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"}