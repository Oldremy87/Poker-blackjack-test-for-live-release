<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PixelPup Video Poker</title>
  <script src="https://hcaptcha.com/1/api.js" async defer></script>

  <style>
    /* ===== Retro PixelPup theme (CSP-safe, no external fonts) ===== */
    :root{
      --ui-scale: 1;
       --hand-gap: 10px;
        --card-ratio: 1.6;   /* height = width * ratio; tweak if your art needs */
      --cardW: 100px;    
      --bg: #0b0f19;
      --panel: #111827;
      --text: #00ffc6;
      --text-dim: #7fffe6;
      --accent: #ffcc00;
      --accent-2: #ff3df7;
      --accent-3: #6ae3ff;
      --card-bg: #222638;
      --card-border: #3af5d9;
      --danger: #ff5577;
      --ok: #45ff99;
       --win-cyan:  #3af5d9;
  --win-pink:  #ff3df7;
  --win-gold:  #ffcc00;
      
    }
    /* Always hide elements with [hidden], and loaders by default */
[hidden] { display: none !important; }
.loading { display: none !important; }     /* stays hidden until .show is added */
.loading.show { display: block !important; }

/* Visually hidden utility */
.sr-only { 
  position: absolute !important;
  width: 1px; height: 1px; padding: 0; margin: -1px;
  overflow: hidden; clip: rect(0,0,1px,1px); white-space: nowrap; border: 0;
}

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(1200px 800px at 50% -20%, #13203b 0%, #0b0f19 60%, #05070d 100%),
        linear-gradient(180deg, #0b0f19 0%, #05070d 100%);
      color: var(--text);
      padding: 24px;
    }
  #toasts {
    position: fixed; top: 12px; right: 12px; z-index: 9999;
    display: flex; flex-direction: column; gap: 8px;
    pointer-events: none;
  }
  .toast {
    pointer-events: auto;
    background: rgba(20,20,20,.92);
    color: #fff; border-radius: 12px; padding: 10px 12px;
    box-shadow: 0 8px 24px rgba(0,0,0,.25);
    font: 600 14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    transform: translateY(-6px); opacity: 0;
    transition: transform .18s ease-out, opacity .18s ease-out;
    max-width: 320px; line-height: 1.25;
    border-left: 4px solid #888;
  }
  .toast.show { transform: translateY(0); opacity: 1; }
  .toast.hide { transform: translateX(8px); opacity: 0; }
  .toast.win   { border-left-color: #22c55e; }  /* green */
  .toast.bonus { border-left-color: #06b6d4; }  /* cyan  */
  .toast.error { border-left-color: #ef4444; }  /* red   */

  .toast .close {
    float: right; margin-left: 8px; font-weight: 700; cursor: pointer; opacity: .7;
  }
  .toast .close:hover { opacity: 1; }

  @media (prefers-reduced-motion: reduce) {
    .toast, .toast.show, .toast.hide { transition: none; }
  }
    /* Header / Nav */
    header { display: flex; align-items: center; justify-content: space-between; gap: 16px; margin: 0 auto 16px; max-width: 1100px; }
    .brand { display: flex; align-items: center; gap: 10px; letter-spacing: 0.5px; text-shadow: 0 0 10px rgba(0,255,198,0.6); }
    .brand-badge {
      width: 36px; height: 36px; border-radius: 10px; border: 2px solid var(--card-border);
      box-shadow: 0 0 14px rgba(0,255,198,0.2); display: grid; place-items: center;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      font-weight: 700; color: var(--accent);
    }
    nav { display: flex; gap: 10px; flex-wrap: wrap; }

    .btn {
      appearance: none; border: 0; cursor: pointer; padding: 10px 14px; border-radius: 12px;
      color: #000; background: var(--accent); text-decoration: none;
      box-shadow: 0 3px 0 #b59000, 0 0 12px rgba(255,204,0,0.35);
      font-weight: 700; letter-spacing: .2px; display: inline-flex; align-items: center; gap: 8px;
      transition: transform .06s ease, filter .12s ease, box-shadow .12s ease;
      font-size: 12px;
    }
    .btn:hover { transform: translateY(-1px); filter: brightness(1.05); }
    .btn:active { transform: translateY(1px); }
    .btn:disabled { background: #555; color: #111; box-shadow: none; cursor: not-allowed; }
    .btn:focus-visible { outline: 2px solid var(--accent-3); outline-offset: 2px; }
    .btn-telegram{
      background: var(--accent-3);
      box-shadow: 0 3px 0 #2aa7bf, 0 0 14px rgba(106,227,255,0.35);
      color: #021018;
    }
    .btn-primary{
      background: var(--accent-2);
      color: #120016;
      box-shadow: 0 3px 0 #a2259c, 0 0 14px rgba(255,61,247,0.35);
    }
    .btn-ghost{
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      color: var(--text);
      border: 1px solid rgba(58,245,217,0.35);
      box-shadow: 0 0 12px rgba(0,255,198,0.18) inset, 0 0 12px rgba(0,255,198,0.12);
    }

    /* Layout panels */
    .wrap { max-width: 1100px; margin: 0 auto; }

/* Stack on tablets/phones */
@media (max-width: 1024px) {
  .hud { grid-template-columns: 1fr; }
  .panel-table, .panel-claim { grid-column: 1; }
}
  .panel {
  /* back to a normal card */
  display: block;
  background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.01));
  border: 1px solid rgba(58,245,217,0.3);
  border-radius: 16px;
  padding: 16px;
  backdrop-filter: blur(4px);
  box-shadow: 0 0 24px rgba(0,255,198,0.06) inset, 0 0 24px rgba(0,255,198,0.08);
}
    .controls { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-top: 8px; }

    .readout { color: var(--text-dim); font-size: 12px; margin: 4px 0; }
    .card {cursor: pointer; user-select: none; }
    /* Hand area (real cards + simulated placeholders share this) */
    .card-hand {
       
       gap: var(--hand-gap);
      display: flex;
      flex-wrap: nowrap;
      justify-content: center;
      align-items: flex-start;
      gap: 10px;
      min-height: 170px;
      margin: 12px auto 0;
      max-width: 1100px;
    }
@keyframes pulse {
  from { opacity: .75; transform: translateY(0); }
  to   { opacity: 1;   transform: translateY(-1px); }
}
    /* Card visual */
    /* Card + placeholder sizing and layout */
.card, .placeholder {
 --_w: calc(var(--cardBaseW, var(--cardW)) * var(--ui-scale));
  width: var(--_w);
  height: calc(var(--_w) * var(--card-ratio)); 
  border-radius: 10px;
  background: var(--card-bg);
  color: #fff;
  border: 2px solid var(--card-border);
  display: grid;
  grid-template-rows: minmax(0, 1fr) auto auto; /* image shrinks first, label, then button */
  align-items: center;
  justify-items: center;
  padding: 8px;
  overflow: hidden;              /* keeps rounded corners clean */
  position: relative;
  text-align: center;
  box-shadow: 0 0 20px rgba(0,255,198,0.1);
}
body.compact {
  --hand-gap: 8px;
}
/* Dealing placeholders centered and unbroken */
.placeholder {
  display: flex;
  align-items: center;
  justify-content: center;
  border-style: dashed;
  font-size: 12px;
  letter-spacing: .5px;
  color: var(--text-dim);
  animation: pulse .9s ease-in-out infinite alternate;
  white-space: nowrap;           /* never break ‚ÄúDealing...‚Äù into ‚Äú...ling‚Äù */
  padding: 0 6px;
}
.controls { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
.controls .btn { flex: 1 1 180px; }
  @media (max-width: 420px) {
  .controls .btn { flex: 1 1 48%; }
}
.card img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  display: block;
}
@media (max-width: 720px){
  header { flex-direction: column; align-items: stretch; gap: 8px; }
  nav { justify-content: center; }
  .brand h1 { font-size: 1.35rem; }
  body { padding: 12px; }
}
@keyframes pulse {
  0% { transform:scale(1); }
  30% { transform:scale(1.08); }
  100% { transform:scale(1); }
}
.payout-pulse { animation: pulse 450ms ease-out; }


/* 2-line clamp for long names like ‚ÄúQueen of Diamonds‚Äù */
.card p {
  margin: 4px 0 0 0;
  font-size: 11px;
  line-height: 1.05;
  padding: 0 4px;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;         /* clamp to 2 lines */
  line-clamp: 2;                 /* standard property for compatibility */
  -webkit-box-orient: vertical;
}

.card button {
  display: none;
  width: 100%;
  min-height: 30px;              /* reliable tap target */
  font-size: 11px;
  padding: 6px 8px;
  border-radius: 8px;
  margin-top: 6px;
  background: var(--accent-2);
  color: #090014;
  box-shadow: 0 2px 0 #a2259c, 0 0 10px rgba(255,61,247,0.35);
}

/* Held badge */
.card.held::after {
  content: 'HELD';
  position: absolute;
  top: 6px; left: 6px;
  font-size: 10px;
  padding: 2px 6px;
  background: var(--accent);
  color: #000;
  border-radius: 6px;
  box-shadow: 0 0 10px rgba(255,204,0,0.4);
}
/* Lightweight confetti (optional flair) */
.fx-confetti{ position:fixed; inset:0; pointer-events:none; z-index:9999; overflow:hidden; }
.fx-confetti i{
  position:absolute; top:-12px; left: var(--x,50%);
  width:8px; height:14px; border-radius:2px;
  background: linear-gradient(var(--rot,0deg),
              var(--win-pink), var(--win-gold), var(--win-cyan));
  opacity:.95;
  transform: rotate(var(--rot,0deg));
  animation: arcade-confetti var(--dur,1200ms) ease-out forwards;
}
@keyframes arcade-confetti{
  0%   { transform: translateY(-10px) rotate(var(--rot,0deg)); }
  100% { transform: translateY(calc(100vh + 12px)) rotate(calc(var(--rot,0deg) + 260deg)); opacity:0; }
}
#payoutTotal{ position: relative; display:inline-block; border-radius:12px; padding:2px 6px; }

/* One-shot bling class we add/remove from JS */
.payout-win{
  /* quick pop + glow + sheen */
  animation:
    arcade-pop .18s ease-out,
    arcade-glow 1.2s ease-out;
  filter: saturate(1.2);
}

/* Neon aura behind the text */
.payout-win::before{
  content:"";
  position:absolute; inset:-8px;
  border-radius:14px;
  background: conic-gradient(from 0deg,
    var(--win-pink), var(--win-gold), var(--win-cyan), var(--win-pink));
  filter: blur(14px) opacity(.55);
  z-index:-1;
  animation: arcade-spin 1.1s ease-out both;
}

/* Shiny sweep across the text */
.payout-win::after{
  content:"";
  position:absolute; inset:-2px;
  border-radius:12px;
  background:
    linear-gradient(120deg,
      rgba(255,255,255,0) 0%,
      rgba(255,255,255,.25) 15%,
      rgba(255,255,255,0) 32%);
  transform: translateX(-140%);
  animation: arcade-sheen .9s ease-out .06s forwards;
  pointer-events:none;
}

@keyframes arcade-pop{
  0% { transform: scale(1); }
  70%{ transform: scale(1.08); }
  100%{ transform: scale(1); }
}
@keyframes arcade-glow{
  0%   { box-shadow: 0 0 0 rgba(0,0,0,0); }
  45%  { box-shadow: 0 0 18px rgba(255,61,247,.25), 0 0 32px rgba(58,245,217,.18) inset; }
  100% { box-shadow: 0 0 0 rgba(0,0,0,0); }
}
@keyframes arcade-spin{
  from { transform: rotate(0deg) scale(1.02); }
  to   { transform: rotate(120deg) scale(1); }
}
@keyframes arcade-sheen{
  to { transform: translateX(140%); }
}
@media (max-width: 600px) {
  .card, .placeholder { width: 80px; height: 138px; }
  .card p { font-size: 10px; }
  .card button { min-height: 28px; font-size: 10px; }
  .card-hand { min-height: 140px; }
}
.callout{
  margin: 8px 0 12px;
  padding: 10px 12px;
  border-radius: 12px;
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
  border: 1px solid rgba(58,245,217,0.45);
  box-shadow: 0 0 18px rgba(0,255,198,0.12) inset, 0 8px 22px rgba(0,0,0,0.25);
  font-size: 13px; line-height: 1.25;
}
.callout strong{ color: var(--accent); margin-right: 6px; }
.callout .close{
  float: right; border: 0; background: transparent; color: var(--text);
  font-weight: 800; cursor: pointer; opacity: .8;
}
.callout .close:hover{ opacity: 1; }

/* Age gate: focus ring for accessibility */
#ageGate :focus-visible { outline: 2px solid var(--accent-3); outline-offset: 2px; }

/* Reduce panel text width for readability on narrow screens */
@media (max-width: 420px){
  #ageGate .brand h1{ font-size: 1.2rem; }
}



    h1 { margin: 0 0 10px; }
        .faucet-form { display: grid; gap: 10px; }
    .field { display: grid; gap: 6px; }
    label { color: var(--text-dim); font-size: 14px; }
    input[type="text"]{
      width: 100%; padding: 12px 14px; border-radius: 12px; border: 1px solid rgba(58,245,217,0.35);
      background: #0f1425; color: var(--text);
      box-shadow: inset 0 0 14px rgba(0,255,198,0.08);
    }

    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }

    .status {
      padding: 10px 12px; border-radius: 12px;
      background: #0f1425; border: 1px solid rgba(58,245,217,0.25);
      color: var(--text-dim);
    }
    .status.ok { border-color: rgba(69,255,153,0.6); color: var(--ok); }
    .status.err { border-color: rgba(255,85,119,0.65); color: var(--danger); }

    footer { opacity: .9; color: var(--text-dim); font-size: 12px; text-align: center; padding: 14px 0 6px; }

.card-hand {
  min-height: 220px;
  margin-top: 16px;
}
@media (min-width: 900px) {
  .card, .placeholder { width: 120px; height: 196px; }
  .card-hand { min-height: 240px; }
}
/* Keep claim pieces tidy */
.claim-block { margin-top: 12px; }
#leaderboardList{ list-style:none; padding:0; margin:0; }
#leaderboardList li{ display:flex; align-items:center; gap:.75rem; padding:.25rem 0; }
#leaderboardList .who{ min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
#leaderboardList .pts{ margin-left:auto; }
#leaderboardList li.you{ font-weight:700; }
.hud {
  display: grid;
  grid-template-columns: 2fr 1fr;
  gap: 12px;
}
.panel-table { grid-column: 1 / 2; }
.panel-claim { grid-column: 2 / 3; }

@media (max-width: 1024px) {
  .hud { grid-template-columns: 1fr; }
  .panel-table, .panel-claim { grid-column: 1 / -1; }  /* <‚Äî ensures stacking */
}
.hidden { display: none !important; }
@property --spin { syntax: "<angle>"; inherits: false; initial-value: 0deg; }

/* Base look for the payout chip */
#payoutTotal{
  display: inline-block;
  padding: 6px 10px;
  border-radius: 12px;
  position: relative;
  background: #0f1425;
  border: 1px solid rgba(58,245,217,.35);
  transition: transform .15s ease, box-shadow .15s ease, filter .15s ease;
}

/* Win pulse: rainbow border + neon glow + bounce */
#payoutTotal.payout-pulse{
  border: 2px solid transparent;
  background:
    linear-gradient(#0f1425, #0f1425) padding-box,
    conic-gradient(from var(--spin),
      #00ffc6, #ffcc00, #ff3df7, #6ae3ff, #00ffc6) border-box;
  color: #ffffff;
  text-shadow:
    0 0 6px #00ffc6,
    0 0 10px #ff3df7,
    0 0 16px #ffcc00;
  box-shadow:
    0 0 18px rgba(0,255,198,.35),
    0 0 28px rgba(255,61,247,.25),
    0 0 40px rgba(255,204,0,.18);
  animation:
    payoutBounce .9s cubic-bezier(.2,1.4,.2,1) 1,
    payoutGlow .9s ease-out 1,
    payoutSpin 1.2s linear 1;
  will-change: transform, box-shadow, filter;
}

@keyframes payoutBounce{
  0%   { transform: scale(1); }
  35%  { transform: scale(1.18) rotate(-0.8deg); }
  65%  { transform: scale(1.10) rotate(0.6deg); }
  100% { transform: scale(1); }
}

@keyframes payoutGlow{
  0%   { filter: saturate(1) brightness(1); }
  40%  { filter: saturate(1.6) brightness(1.25); }
  100% { filter: saturate(1) brightness(1); }
}

@keyframes payoutSpin{
  to { --spin: 360deg; }
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce){
  #payoutTotal.payout-pulse{
    animation: none;
    box-shadow: 0 0 18px rgba(0,255,198,.35);
  }
}


    </style>
</head>
<script>
  function fitHandToWidth() {
    const hand = document.getElementById('hand');
    if (!hand) return;

    // How wide is the hand area?
    const styles = getComputedStyle(hand);
    const gap = parseFloat(styles.gap || styles.columnGap || 10) || 10;
    const cards = 5, gaps = cards - 1;

    const available = hand.clientWidth; // visible width
    // space for 5 cards + 4 gaps
    const perCard = (available - gap * gaps) / cards;

    // clamp so it looks good everywhere
    const cardW = Math.max(58, Math.min(perCard, 130));

    document.documentElement.style.setProperty('--cardW', cardW + 'px');
  }

  addEventListener('load', fitHandToWidth);
  addEventListener('resize', fitHandToWidth);
  function enterSite() {
    localStorage.setItem('ageVerified', 'true');
    document.getElementById('ageGate').style.display = 'none';
  }
  window.addEventListener('load', () => {
    if (localStorage.getItem('ageVerified') === 'true') {
      document.getElementById('ageGate').style.display = 'none';
    }
  });
</script>
<div id="cookieBar" class="cookie-bar" role="region" aria-label="Cookie notice" hidden>
  <span>
    PixelPup Poker uses cookies & session storage to keep you logged in and prevent abuse.
    By continuing, you agree to our <a href="privacy.html">Privacy Policy</a>.
  </span>
  <button id="cookieAccept" class="btn">Accept</button>
</div>
<script>
(function () {
  const KEY = 'kk_cookie_consent_v1';
  function initCookieBar(){
    const bar = document.getElementById('cookieBar');
    const btn = document.getElementById('cookieAccept');
    if (!bar || !btn) return;
    try {
      if (localStorage.getItem(KEY) === 'true') return;
      bar.hidden = false;
      btn.addEventListener('click', () => {
        localStorage.setItem(KEY, 'true');
        bar.hidden = true;
      });
    } catch {
      bar.hidden = false;
      btn.addEventListener('click', () => bar.hidden = true);
    }
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCookieBar);
  } else {
    initCookieBar();
  }
})();
</script>

 

</style>
<body>
<!-- Themed Age Gate Overlay -->
<div id="ageGate"
     role="dialog"
     aria-labelledby="ageTitle"
     aria-describedby="ageDesc"
     aria-modal="true"
     style="position:fixed; inset:0; z-index:9999; display:none;">
  <!-- Backdrop -->
  <div class="age-backdrop" style="position:absolute; inset:0;
    background:
      radial-gradient(1200px 800px at 50% -20%, #13203b 0%, #0b0f19 60%, #05070d 100%),
      linear-gradient(180deg, #0b0f19 0%, #05070d 100%);
    opacity:.98;"></div>

  <!-- Centered panel (NOTE: inside #ageGate) -->
  <div class="age-wrap" style="position:relative; height:100%; display:flex; align-items:center; justify-content:center; padding:24px;">
    <div class="panel" style="max-width:560px; width:100%; text-align:center;">
      <div class="brand" style="justify-content:center; margin-bottom:8px;">
        <div class="brand-badge">KK</div>
        <h1 id="ageTitle" style="margin:0;">PixelPup Poker Alpha</h1>
      </div>

      <p id="ageDesc" class="readout" style="margin:6px 0 16px;">
        You must be <strong>18 or older</strong> to participate in this alpha test.
      </p>

      <div class="panel" style="margin: 12px 0;">
        <p class="readout" style="margin:6px 0;">
          This is a free alpha test. No real money. Tokens have no monetary value.
        </p>
        <p class="readout" style="margin:6px 0;">
          See our <a href="disclaimer.html">Disclaimer</a>, <a href="tos.html">Terms</a>, and <a href="privacy.html">Privacy</a>.
        </p>
      </div>

      <div class="controls" style="margin-top:12px;">
        <button id="ageConfirm" class="btn btn-primary" type="button" aria-label="I am 18 or older">I am 18+</button>
        <a class="btn btn-ghost" href="https://www.google.com" aria-label="Exit site">Exit</a>
      </div>

      <label class="readout" style="display:inline-flex; gap:8px; align-items:center; margin-top:10px;">
        <input id="ageRemember" type="checkbox" style="accent-color: var(--accent);" />
        Remember this on this device
      </label>
    </div>
  </div>

  <noscript>
    <div style="position:absolute;bottom:0;left:0;right:0;text-align:center;color:white;padding:8px;background:#111827;">
      JavaScript is required to enter.
    </div>
  </noscript>
</div>


  <noscript>
    <div style="position:absolute;bottom:0;left:0;right:0;text-align:center;color:white;padding:8px;background:#111827;">
  
    </div>
  </noscript>
</div>

</div>

    <header>
    <nav>
  <a class="btn btn-telegram" href="https://t.me/NexaKennelKlub" target="_blank" rel="noopener noreferrer">
    <!-- Telegram SVG -->
    <svg class="icon" viewBox="0 0 24 24" aria-hidden="true" style="width:18px;height:18px;margin-right:6px;">
      <path fill="#1C93E3" d="M12 0a12 12 0 1 0 0 24A12 12 0 0 0 12 0z"/>
      <path fill="#fff" d="M17.9 7.4c.2-1-.8-1.3-1.6-1l-11 4.2c-.7.3-.7.8-.1 1l2.8.9 6.5-4.1c.3-.2.6-.1.4.1l-5.3 4.9-.2 3.1c.5 0 .7-.2 1-.5l1.7-1.6 2.6 1.9c.6.3 1 .1 1.1-.6l1.9-9.3z"/>
    </svg>
    Join Telegram
  </a>

  <a class="btn btn-ghost" href="https://x.com/Oldremy" target="_blank" rel="noopener noreferrer">
    <!-- X SVG -->
    <svg class="icon" viewBox="0 0 24 24" aria-hidden="true" style="width:18px;height:18px;margin-right:6px;">
      <path fill="currentColor" d="M18.9 2H22l-7.7 8.8L22.7 22h-7.1l-5.5-7.3L3.8 22H1l8.4-9.6L1 2h7.2l5 6.7L18.9 2zM17.6 20h1.9L7.4 4H5.6l12 16z"/>
    </svg>
    @Oldremy
  </a>

  <a class="btn btn-ghost" href="https://x.com/NexaKennelKlub" target="_blank" rel="noopener noreferrer">
    <svg class="icon" viewBox="0 0 24 24" aria-hidden="true" style="width:18px;height:18px;margin-right:6px;">
      <path fill="currentColor" d="M18.9 2H22l-7.7 8.8L22.7 22h-7.1l-5.5-7.3L3.8 22H1l8.4-9.6L1 2h7.2l5 6.7L18.9 2zM17.6 20h1.9L7.4 4H5.6l12 16z"/>
    </svg>
    @NexaKennelKlub
  </a>
      <a class="btn btn-ghost" href="/"              class="kk-home" aria-label="Go to Home">üè† Home</a>
     <a class = "btn btn-primary" href="blackjack.html">Play BlackJack</a>
     <a class = "btn btn-ghost" href="/connect.html" aria-current="page">Connect Wallet</a>



  
</nav>
    <div class="brand">
      <div class="brand-badge">KK</div>
      <h1>PixelPup Video Poker</h1>
    </div>
  </header>

  <div class="wrap">
    <!-- HUD -->
    <div class="hud">
      <div class="panel panel-table" id="game">
    <h1>Table</h1>
    <div class="controls">
      <div id="vpHow" class="callout" role="region" aria-label="How to play video poker">
  <strong>How to play:</strong>
  Deal ‚Üí tap cards to <em>HOLD</em> ‚Üí Draw once. Get the best 5 card hand you can. Payouts: RF 250, SF 50, 4K 25, FH 9, Flush 6, Straight 4, 3K 3, 2 Pair 2, Jacks+ 1.
  <a href="pointstable.html" class="btn btn-ghost" style="margin-left:8px;">Full payouts</a>
  <button class="close" aria-label="Hide tips">√ó</button>
</div>

      <p id="userTag" class="readout"></p>
      <p id="fairInfo" class="readout"></p>
      <button id="betBtn" class="btn btn-primary">Place 10 KIBL bet</button>
      <button id="draw" class="btn" disabled>Draw</button>
    </div>
    <div id="hand" class="card-hand" aria-live="polite"></div>
    <p class="readout">Tap a card to keep it for the draw.</p>
    <a class="btn btn-ghost" href="achievements.html">Achievements</a>
     <a class="btn btn-ghost" href="pointstable.html">Point Table</Table></a>
     <p id="payoutTotal">Total Payout: 0 KIBL</p>
     <p id="kiblBalance">KIBL: ‚Äî</p>
     <p id="nexaBalance">NEXA: ‚Äî</p>
  </div>

  <!-- RIGHT SIDEBAR: TOTAL + CLAIM + DAILY -->
  <div class="panel panel-claim">
    <div class="controls">
      <button id="dailyReward" class="btn btn-ghost">Claim Daily Reward</button>
      <div class="panel" id="leaderboardPanel">
  <h2>Season Points Window (Skill Points)</h2>
  <ol id="leaderboardList" class="leaderboard"></ol>
  <div class="readout" style="margin-top:6px;">
   <a class="btn btn-ghost" href="/leaderboard.html?game=poker">See full leaderboard ‚Üí</a>
</div>
</div>

    </div>
<section id="claim" class="claim-block">
  <h2>Claim</h2>
  <form class="faucet-form" id="faucetForm" onsubmit="return false;" autocomplete="off">
    <div class="field">
      <label for="addressInput">Wallet address</label>
      <input
  type="text"
  id="addressInput"
  placeholder="Enter your Nexa address (e.g., nexa:...)"
  aria-label="Nexa address input"
  required
  spellcheck="false"
  autocapitalize="off"
  autocomplete="off"
  inputmode="latin"
/>

    </div>
    <div class="field">
      <label>Human check</label>
      <div id="payoutCaptcha" class="h-captcha"
     data-sitekey="170a6dc4-35b6-4266-a2ce-6f3eb8c85d9c"
     data-size="normal"></div>

    </div>
    <div class="row">
      <button class="btn btn-primary" id="ClaimPayout" type="button" aria-label="Claim Payout">FEED ME! üêæ</button>

    </div>
  </form>
  <div id="loading" class="status" aria-live="polite" style="display:none;">Processing your request...</div>
  <p id="result" aria-live="polite">Idle</p>
</section>
      
    </div>

  <audio id="feedSound" src="dogfood.mp3" preload="auto"></audio>
  
  
 
<script>
  window.KIBL_TOKEN_ID_HEX = "656bfefce8a0885acba5c809c5afcfbfa62589417d84d54108e6bb42a6f30000";

document.addEventListener('DOMContentLoaded', async () => {
  try {
    await fetchCsrf();
    dealBtn.disabled = false;
    await (window.loadProfile?.());
    await (window.loadLeaderboard?.());
  } catch {
    alert('Could not initialize security token. Refresh to try again.');
  }
});

  // ---- constants so we don't typo ids/paths ----
const IDS = Object.freeze({
  payout: 'payoutTotal',
  achievements: 'achievements',
  deal: 'deal',
  draw: 'draw',
  daily: 'dailyReward',
  claimButton: 'ClaimPayout',
  hand: 'hand',
  address: 'addressInput',
  loading: 'loading',
  leaderboardList: 'leaderboardList'
});

const API = Object.freeze({
  csrf: '/api/csrf',
  start: '/api/start-hand',
  deal: '/api/deal',
  draw: '/api/draw',
  profile: '/api/profile',
  leaderboard: '/api/leaderboard',
  daily: '/api/daily-reward',
  payout: '/api/payout'
});
  // ===== Get existing elements by their current ids (no renames) =====
 const payoutBtn      = document.getElementById(IDS.claimButton);
const addressInput   = document.getElementById(IDS.address);
const loading        = document.getElementById(IDS.loading);
const payoutLoading  = loading;
const dailyRewardBtn = document.getElementById(IDS.daily);
const dealBtn        = document.getElementById(IDS.deal);
const drawBtn        = document.getElementById(IDS.draw);
const payoutEl       = document.getElementById(IDS.payout);
const achievementsEl = document.getElementById(IDS.achievements);
const handContainer  = document.getElementById(IDS.hand);
const feedSound = document.getElementById('feedSound');

    let __csrf = null;
    async function fetchCsrf(){
      const r = await fetch('/api/csrf', { credentials:'include' });
      if (!r.ok) throw new Error('CSRF bootstrap failed');
      const { csrfToken } = await r.json();
      __csrf = csrfToken;
    }

function postWithCsrf(input, init = {}) {
  const baseHeaders = init.headers ? {...init.headers} : {};
  if (init.body && !baseHeaders['Content-Type']) baseHeaders['Content-Type'] = 'application/json';
  const makeReq = async () => fetch(input, {
    ...init,
    method: init.method || 'POST',
    credentials: 'include',
    headers: { 'x-csrf-token': __csrf, ...baseHeaders }
  });
  // 403 ‚Üí refresh CSRF once
  return (async () => {
      let resp = await makeReq();
      if (resp.status === 403) {
      const data = await resp.clone().json().catch(()=> ({}));
      if (data?.error === 'bad_csrf') { await fetchCsrf(); resp = await makeReq(); }
    }
    return resp;
  })();
}
  let _busy = false;
    function lock(btn){ _busy = true; if(btn) btn.disabled = true; }
    function unlock(btn){ _busy = false; if(btn) btn.disabled = false; }

  let totalPayout = 0;
  let hand = [];
  let held = [false, false, false, false, false];
  const achievementBonuses = { firstWin: 100, '10Wins': 1000, '25Wins': 2500, '50Wins': 5000, royalFlush: 50000 };

  function show(el){ el && (el.style.display = 'block'); }
  function hide(el){ el && (el.style.display = 'none'); }
  const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

  function toast(html, { type = 'info', timeout = 2500 } = {}) {
    let root = document.getElementById('toasts');
    if (!root) {
      root = document.createElement('div');
      root.id = 'toasts';
      document.body.appendChild(root);
    }
    const el = document.createElement('div');
    el.className = `toast ${type}`;
    el.setAttribute('role', 'status');
    el.setAttribute('aria-live', 'polite');
    el.innerHTML = `<span class="close" aria-label="Dismiss">√ó</span>${html}`;
    root.appendChild(el);

    // enter
    requestAnimationFrame(() => el.classList.add('show'));

    // auto-dismiss
    const remove = () => {
      el.classList.remove('show');
      el.classList.add('hide');
      el.addEventListener('transitionend', () => el.remove(), { once: true });
    };
    const t = setTimeout(remove, timeout);

    // click to dismiss immediately
    el.querySelector('.close').addEventListener('click', () => {
      clearTimeout(t);
      remove();
    });

    // light haptic on mobile (best-effort)
    if (navigator.vibrate) { navigator.vibrate(20); }
  }
function flashPayout(){
  if (!payoutEl) return;
  // retrigger the one-shot animation reliably
  payoutEl.classList.remove('payout-win');
  // force reflow
  void payoutEl.offsetWidth;
  payoutEl.classList.add('payout-win');
  // clean up after the glow ends
  setTimeout(() => payoutEl?.classList.remove('payout-win'), 1400);
}
async function loadWalletBalances(address) {
  if (!address) return;
  try {
    const r = await fetch(`/api/wallet/balance?address=${encodeURIComponent(address)}`, { credentials: 'include' });
    const j = await r.json();
    if (!j?.ok) return;

    const kiblEl = document.getElementById('kiblBalance');
    if (kiblEl) kiblEl.textContent = `KIBL: ${j.kibl}`;

    const nexaEl = document.getElementById('nexaBalance');
    if (nexaEl) nexaEl.textContent = `NEXA: ${j.nexa}`;
  } catch (e) {
    console.error('loadWalletBalances failed:', e);  
  }
}


function confettiBurst(count = 48, ms = 1800){
  const wrap = document.createElement('div');
  wrap.className = 'fx-confetti';
  document.body.appendChild(wrap);
  for (let i=0;i<count;i++){
    const s = document.createElement('i');
    s.style.setProperty('--x', `${Math.random()*100}%`);
    s.style.setProperty('--rot', `${Math.random()*360}deg`);
    s.style.setProperty('--dur', `${1000 + Math.random()*700}ms`);
    wrap.appendChild(s);
  }
  setTimeout(()=> wrap.remove(), ms + 300);
}
// --- Size/fit controls ---
const sizeSlider = document.getElementById('bjSize');
const fitBtn     = document.getElementById('bjFit');

function applyScaleFromSlider(){
  const v = Math.max(80, Math.min(125, Number(sizeSlider?.value||100)));
  const scale = v / 100;
  document.documentElement.style.setProperty('--ui-scale', String(scale));
  try { localStorage.setItem('kk_bj_scale', String(v)); } catch {}
}

// Compute a base card width that fits the widest row we can see
function fitBjToScreen(){
  const panel = document.getElementById('bjPanel');
  if (!panel) return;

  const gap = parseFloat(getComputedStyle(document.documentElement)
               .getPropertyValue('--hand-gap') || '10') || 10;

  // How many cards in the widest visible row?
  const dealerCount = document.querySelectorAll('#bjDealer .card').length || 2;
  const rowCounts = Array.from(document.querySelectorAll('#bjPlayer .hand-row'))
                    .map(r => r.querySelectorAll('.card, .placeholder').length);
  const n = Math.max(dealerCount, ...(rowCounts.length ? rowCounts : [2]));

  // Available width inside the table panel (minus a little padding)
  const available = panel.clientWidth - 32;
  const perCard = (available - gap * (n - 1)) / n;

  // Clamp so it always looks nice
  const base = Math.max(64, Math.min(perCard, 136)); // px
  document.documentElement.style.setProperty('--cardBaseW', base + 'px');
}

function initBjSizeUI(){
  // Restore saved scale
  try {
    const saved = Number(localStorage.getItem('kk_bj_scale'));
    if (sizeSlider && saved) sizeSlider.value = saved;
  } catch {}
  applyScaleFromSlider();
  fitBjToScreen();

  sizeSlider?.addEventListener('input', applyScaleFromSlider);
  fitBtn?.addEventListener('click', fitBjToScreen);

  // Re-fit on window resize
  window.addEventListener('resize', fitBjToScreen);

  // Re-fit whenever hands change (hit/stand/split/double)
  const player = document.getElementById('bjPlayer');
  const dealer = document.getElementById('bjDealer');
  const mo = new MutationObserver(fitBjToScreen);
  if (player) mo.observe(player, { childList:true, subtree:true });
  if (dealer) mo.observe(dealer, { childList:true, subtree:true });
}

// Call once when the page boots (after DOM ready)
initBjSizeUI();

  
  
  function clearSimulatedDeal() {
    [...handContainer.querySelectorAll('.placeholder')].forEach(ph => ph.remove());
  }

function showSimulatedDeal(duration = 1400) {
  handContainer.innerHTML = '';
  const placeholders = [];
  for (let i = 0; i < 5; i++) {
    const ph = document.createElement('div');
    ph.className = 'placeholder';
    ph.textContent = 'Dealing...';
    handContainer.appendChild(ph);
    placeholders.push(ph);
  }
  // simple stagger to feel like a real deal
  placeholders.forEach((ph, i) => {
    setTimeout(() => {
      ph.style.filter = 'brightness(1.15)';
      ph.style.transform = 'translateY(-2px)';
    }, 120 * i);
  });
  // guarantee the placeholders stay visible for at least `duration`
  return wait(duration);
}
const HCAPTCHA_SITE_KEY = '170a6dc4-35b6-4266-a2ce-6f3eb8c85d9c';

let widgetId = null;
let pendingResolve = null;
(function () {
    const KEY = 'kk_cookie_consent_v1';
    const bar = document.getElementById('cookieBar');
    const btn = document.getElementById('cookieAccept');
    try {
      if (localStorage.getItem(KEY) === 'true') return;
      bar.hidden = false;
      btn.addEventListener('click', () => {
        localStorage.setItem(KEY, 'true');
        bar.hidden = true;
      });
    } catch {
      // if storage blocked, just show once
      bar.hidden = false;
      btn.addEventListener('click', () => bar.hidden = true);
    }
  })();
// Called by the hCaptcha script tag (?onload=onHCaptchaLoad)
function onHCaptchaLoad() {
  const el = document.getElementById('payoutCaptcha');
  if (!el) {
    console.error('Missing #payoutCaptcha element in DOM.');
    return;
  }
  if (widgetId !== null) return; // already rendered (idempotent)

  widgetId = hcaptcha.render(el, {
    sitekey: HCAPTCHA_SITE_KEY,
    size: 'invisible',
    callback: (token) => {
      if (pendingResolve) {
        pendingResolve(token);
        pendingResolve = null;
      }
    },
    'error-callback': () => {
      if (pendingResolve) {
        pendingResolve(Promise.reject(new Error('hCaptcha error')));
        pendingResolve = null;
      }
    },
    'close-callback': () => {
      if (pendingResolve) {
        pendingResolve(Promise.reject(new Error('hCaptcha closed')));
        pendingResolve = null;
      }
    }
  });
}

function waitForWidget() {
  return new Promise((resolve) => {
    if (widgetId !== null) return resolve(widgetId);
    // If hcaptcha loaded but didn‚Äôt render yet, try again after DOMContentLoaded/onload
    const check = () => {
      if (widgetId !== null) resolve(widgetId);
      else setTimeout(check, 50);
    };
    check();
  });
}
function announceAndRefresh(d){
  const creditUnits  = Math.floor((d.credit || 0) / 100);
  const balanceUnits = Math.floor((d.sessionBalance || 0) / 100);

  if (d.bonuses?.length) {
    const lines = d.bonuses
      .map(b => `‚Ä¢ ${Math.floor((b.amount || 0) / 100)} KIBL ‚Äî ${b.name}`)
      .join('<br>');
    toast(`<strong>Bonuses unlocked</strong><br>${lines}`, { type: 'bonus', timeout: 1500 });
  }
  if (creditUnits > 0) {
    toast(`You won <strong>${creditUnits}</strong> KIBL!`, { type: 'win', timeout: 1500 });
  }

  payoutEl.textContent = `Total Payout: ${balanceUnits} KIBL`;
  totalPayout = balanceUnits;
  payoutBtn.disabled = (totalPayout === 0);

  // Always refresh profile + leaderboard so numbers are current
  loadProfile();
  loadLeaderboard();
}

async function getCaptchaToken() {
  await waitForWidget();
  return new Promise((resolve, reject) => {
    pendingResolve = resolve;
    try {
      hcaptcha.execute(widgetId);
    } catch (e) {
      pendingResolve = null;
      reject(e);
    }
  });
}
async function loadProfile(){
  try{
    const r = await fetch(API.profile, { credentials: 'include' });
    const d = await r.json();
    if (!d.ok) return;

    const bankUnits = Math.floor((d.bank || 0) / 100);
    totalPayout = bankUnits;
    if (payoutEl) payoutEl.textContent = `Total Payout: ${bankUnits} KIBL`;
    if (payoutBtn) payoutBtn.disabled = (totalPayout === 0);
    // NEW: show player tag
  const tagEl = document.getElementById('userTag');
  if (tagEl && d.displayId) tagEl.textContent = `Your tag: ${d.displayId}`;

    // show ONLY Poker achievements on the poker page
    const ach = d.stats?.poker?.achievements || {};
    const list = Object.entries(ach).filter(([,v]) => v).map(([k]) => k.replace(/([A-Z])/g, ' $1').trim());
    if (achievementsEl) {
  achievementsEl.textContent = list.length
    ? `Achievements: ${list.join(', ')}`
    : 'Achievements: ‚Äî';
    }
  } catch {}
}
async function loadLeaderboard(){
  try{
    const res = await fetch('/api/leaderboard/window?game=poker&k=3', { credentials:'include' });
    const d = await res.json(); if (!d.ok) return;

    const list = document.getElementById('leaderboardList');
    if (!list) return;
    list.innerHTML = '';

    d.window.forEach(row => {
      const li = document.createElement('li');
      li.innerHTML = `
        <span class="who">${row.rank}. <span class="user">${row.user}${row.you ? ' (you)' : ''}</span></span>
        <span class="pts">${row.points}</span>`;
      if (row.you) li.classList.add('you');
      list.appendChild(li);
    });

    let hint = document.getElementById('lbHint');
    if (!hint) {
      hint = document.createElement('div');
      hint.id = 'lbHint';
      hint.className = 'readout';
      list.parentNode.appendChild(hint);
    }
    hint.textContent = (d.you && d.you.deltaAhead != null)
      ? `Only ${d.you.deltaAhead} pts to the next rank.`
      : '';
  } catch(e){ console.warn('poker window LB failed', e); }
}

 function formatWait(ms) {
  if (!Number.isFinite(ms) || ms <= 0) return 'a bit';
  const m = Math.ceil(ms / 60000);
  return `${m} minute${m !== 1 ? 's' : ''}`;
}
const sleep = (ms) => new Promise(r => setTimeout(r, ms));
const REVEAL_EXTRA_MS = 600 ; 
async function startGame() {
  // 1) Start-hand gate FIRST
  let start;
  try {
    start = await postWithCsrf(API.start, {
  method: 'POST',
  credentials: 'include',
});

  } catch {
    alert('Network error starting hand.'); return;
  }
  let startData;
  try { startData = await start.json(); } catch { startData = {}; }
  if (startData?.commit && startData?.handId) {
  const fi = document.getElementById('fairInfo');
  if (fi) fi.textContent = `Commit: ${startData.commit.slice(0,10)}‚Ä¶ (hand ${startData.handId.slice(0,8)})`;
}
  if (!start.ok || !startData.ok) {
    if (startData?.error === 'ip_limit') {
      alert(`Play limit reached. Come back in ${formatWait(startData.retryMs)}.`);
    } else if (startData?.error) {
      alert(`Start-hand failed: ${startData.error}`);
    } else {
      alert(`Start-hand failed: ${start.statusText}`);
    }
    return;
  }

  // 2) Simulated deal animation (keep visible ‚â•1.5s)
  const anim = showSimulatedDeal(1500);
  try { feedSound.currentTime = 0; feedSound.play(); } catch {}
  dealBtn.disabled = true;

  // 3) Request the actual deal in parallel with the animation
  const dealReq = postWithCsrf(API.deal, {method: 'POST',credentials: 'include'});
  try {
    const [resp] = await Promise.all([dealReq, anim]);
    const data = await resp.json();
    if (!resp.ok || !data.ok) {
      alert('Deal failed: ' + (data.error || resp.statusText));
      dealBtn.disabled = false;
      return;
    }
    hand = data.hand || [];
    held = [false, false, false, false, false];
    renderHand();
    drawBtn.disabled = false;
  } catch (e) {
    console.error(e);
    alert('Deal failed.');
    dealBtn.disabled = false;
  }
}
  
  function renderHand() {
    handContainer.innerHTML = '';
    hand.forEach((card, index) => {
      const cardDiv = document.createElement('div');
      cardDiv.classList.add('card');
      cardDiv.setAttribute('role', 'button');
      cardDiv.setAttribute('tabindex', '0');
      cardDiv.setAttribute('aria-pressed', held[index] ? 'true' : 'false');
      cardDiv.title = held[index] ? 'Click to unhold' : 'Click to hold';
      cardDiv.addEventListener('click', () => toggleHold(index));
      cardDiv.addEventListener('keydown', (e) => {
        if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); toggleHold(index); }
      });

      const img = document.createElement('img');
      img.src = `cards/${card.filename}`;
      img.alt = card.displayText;

      const label = document.createElement('p');
      label.textContent = card.displayText;

      const holdButton = document.createElement('button');
      holdButton.textContent = held[index] ? 'Unhold' : 'Hold';
      holdButton.addEventListener('click', (e) => { e.stopPropagation(); toggleHold(index); });

      cardDiv.appendChild(img);
      cardDiv.appendChild(label);
      cardDiv.appendChild(holdButton);
      if (held[index]) cardDiv.classList.add('held');
      handContainer.appendChild(cardDiv);
      fitBjToScreen();
    });
  }

  function toggleHold(i) {
    held[i] = !held[i];
    renderHand();
  }const nextPaint = () => new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

async function waitForImagesDecoded(el) {
  const imgs = Array.from(el.querySelectorAll('img'));
  await Promise.all(imgs.map(img => {
    if ('decode' in img) return img.decode().catch(()=>{});
    if (img.complete) return Promise.resolve();
    return new Promise(res => { img.onload = img.onerror = () => res(); });
  }));
}
async function draw() {
  try {
    const resp = await postWithCsrf(API.draw, {
      method: 'POST',
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ held })
    });
   
    const data = await resp.json();
    if (data.fair?.serverSeed) {
      const fi = document.getElementById('fairInfo');
      if (fi) fi.textContent = `Reveal: seed=${data.fair.serverSeed.slice(0,12)}‚Ä¶ ‚Ä¢ verify: /api/fair/${data.fair.handId}`;
    }
    if (!resp.ok || !data.ok) {
      const e = data.error || resp.statusText;
      if (e === 'too_fast')            alert('You‚Äôre drawing too fast ‚Äî wait a moment and try again.');
      else if (e === 'deal_first')     alert('You need to Deal before you can Draw.');
      else if (e === 'already_drawn')  alert('Round finished. Hit Deal for a new hand.');
      else if (e === 'use_start_hand_first') alert('Please hit ‚ÄúFeed the dealer‚Äù to start a hand.');
      else if (e === 'bad_hold_array') alert('Something went wrong with your holds ‚Äî try again.');
      else                              alert('Draw failed: ' + e);
      return;
    }

   hand = data.hand; 
    renderHand(); // inserts <img> cards
    const creditUnits  = Math.floor((data.credit || 0) / 100);
    const balanceUnits = Math.floor((data.sessionBalance || 0) / 100);

     // Update UI state immediately so this paint reflects the new values
    if (payoutEl) payoutEl.textContent = `Total Payout: ${balanceUnits} KIBL`;
    totalPayout = balanceUnits;
    if (payoutBtn) payoutBtn.disabled = (totalPayout === 0);
    if (dealBtn)  dealBtn.disabled  = false;
    if (drawBtn)  drawBtn.disabled  = true;

    // Let the browser paint the new hand (and decode images) before blocking alerts
    await nextPaint();
    await waitForImagesDecoded(handContainer);
    await sleep(REVEAL_EXTRA_MS);
    fitBjToScreen();
    if (data.bonuses?.length) {
      const lines = data.bonuses
    .map(b => `‚Ä¢ ${Math.floor((b.amount || 0) / 100)} KIBL ‚Äî ${b.name}`)
    .join('<br>');
      toast(`<strong>Bonuses unlocked</strong><br>${lines}`, { type: 'bonus', timeout: 1200 });
      }

    if (creditUnits > 0) {
      // Sound: restart and play (user gesture already happened)
    const sfx = document.getElementById('feedSound');
    if (sfx) { try { sfx.currentTime = 0; sfx.volume = 0.6; sfx.play().catch(()=>{}); } catch(_){} }
       flashPayout();

  // üéâ optional quick confetti burst (comment out if you prefer)
  confettiBurst();
    // Haptic (best-effort on mobile)
    if (navigator.vibrate) { navigator.vibrate([10, 40, 10]); }

    // Pulse the payout readout
    payoutEl.classList.add('payout-pulse');
    setTimeout(() => payoutEl.classList.remove('payout-pulse'), 1900);
    }
    // Fetch profile/leaderboard AFTER the user sees cards + alerts
    // (non-blocking for snappier UX)
    loadProfile();
    loadLeaderboard();
    
  } catch (e) {
    console.error(e);
    alert('Draw failed.');
  }
}

async function onDailyReward() {
  try {
    const res = await postWithCsrf(API.daily, { method: 'POST',
  credentials: 'include',
});
    
    const data = await res.json();
    if (!res.ok || !data.ok) {
      const mins = data.retryInMs ? Math.ceil(data.retryInMs/60000) : 'later';
      alert('Daily reward already claimed. Try again in ~' + mins + ' minutes.');
      return;
    }

    // Convert minor units -> standard units
    const creditUnits  = Math.floor((data.credit || 0) / 100);
    const balanceUnits = Math.floor((data.sessionBalance || 0) / 100);

    alert(`Daily reward claimed: +${creditUnits} KIBL`);

    // Display server balance only (already /100)
    totalPayout = balanceUnits;
    if (payoutEl) payoutEl.textContent = `Total Payout: ${totalPayout} KIBL`;
    payoutBtn.disabled = (totalPayout === 0);
  } catch (e) {
    console.error(e);
    alert('Failed to claim daily reward, please try again.');
  }
}

async function onClaimPayout() {
    if (totalPayout === 0) {
    // Double-check with the server in case the local variable is stale
    try {
      const r = await fetch(API.profile, { credentials: 'include' });
      const d = await r.json();
      if (d?.ok) {
        const bankUnits = Math.floor((d.bank || 0) / 100);
        totalPayout = bankUnits;
        if (payoutEl) payoutEl.textContent = `Total Payout: ${bankUnits} KIBL`;
        if (payoutBtn) payoutBtn.disabled = (totalPayout === 0);
      }
    } catch {}
    if (totalPayout === 0) { alert('No payout to claim!'); return; }
 }

  const playerAddress = addressInput.value.trim();
  if (!/^nexa:/.test(playerAddress)) {
    alert('Please enter a valid Nexa address (nexa:...)');
    return;
  }

  // Visible hCaptcha: ensure the user solved the challenge first
  const token = window.hcaptcha?.getResponse?.();
  if (!token) {
    // nudge: focus the widget and ask the user to complete it
    document.querySelector('#payoutCaptcha iframe')?.focus();
    alert('Please complete the hCaptcha challenge first.');
    return;
  }

  try {
    show(payoutLoading);
    payoutBtn.disabled = true;

    const resp = await postWithCsrf(API.payout, {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        playerAddress,
        'h-captcha-response': token    // <- standard field name
      })
    });

    const data = await resp.json().catch(() => ({}));

    if (!resp.ok || data.error) {
      try { window.hcaptcha?.reset?.(); } catch {}
      alert('Payout failed: ' + (data.error || resp.statusText));
      return;
    }

    try { feedSound.currentTime = 0; feedSound.play(); } catch {}
    alert(`Payout successful! Tx ID: ${data.txId}`);

    totalPayout = data.remainingKIBL ?? 0;
    payoutEl.textContent = `Total Payout: ${totalPayout} KIBL`;
    payoutBtn.disabled = (totalPayout === 0);
    // Reset so the user can claim again in the future
    try { window.hcaptcha?.reset?.(); } catch {}

  } catch (e) {
    console.error('Payout failed:', e);
    try { window.hcaptcha?.reset?.(); } catch {}
    alert(e?.message || 'Payout failed. Try again.');
  } finally {
    hide(payoutLoading);
    payoutBtn.disabled = (totalPayout === 0);
  }
}



  function checkAchievements() {}
    

  // ===== Wire up existing buttons/ids without renaming them =====
  dailyRewardBtn?.addEventListener('click', onDailyReward);
  dealBtn?.addEventListener('click', startGame);
  drawBtn?.addEventListener('click', draw);
  payoutBtn?.addEventListener('click', onClaimPayout);

  // Minor UX: address field hint border
  addressInput.addEventListener('input', () => {
    const v = addressInput.value.trim();
    addressInput.style.borderColor = (v && !/^nexa:/.test(v)) ? '#ff5555' : 'rgba(58,245,217,0.35)';
  });

(() => {
  const LS_KEY = 'ageVerified';
  const ageGate = document.getElementById('ageGate');
  const confirmBtn = document.getElementById('ageConfirm');
  const rememberCb = document.getElementById('ageRemember');

  // Simple focus trap inside the age gate
  function trapFocus(e){
    if (!ageGate || ageGate.style.display === 'none') return;
    const f = ageGate.querySelectorAll('button, a[href], input, [tabindex]:not([tabindex="-1"])');
    if (!f.length) return;
    const first = f[0], last = f[f.length - 1];
    if (e.key === 'Tab'){
      if (e.shiftKey && document.activeElement === first){ last.focus(); e.preventDefault(); }
      else if (!e.shiftKey && document.activeElement === last){ first.focus(); e.preventDefault(); }
    } else if (e.key === 'Escape'){
      // Esc doesn't bypass the gate; keep focus in dialog
      first.focus();
      e.preventDefault();
    }
  }

  function showGate(){
    ageGate.style.display = 'block';
    document.body.style.overflow = 'hidden';
    setTimeout(() => confirmBtn?.focus(), 0);
    document.addEventListener('keydown', trapFocus);
  }
  function hideGate(){
    ageGate.style.display = 'none';
    document.body.style.overflow = '';
    document.removeEventListener('keydown', trapFocus);
  }
  window.loadWalletBalances = loadWalletBalances;
  window.addEventListener('load', () => {
    // Respect previous confirmation
    const ok = localStorage.getItem(LS_KEY) === 'true' || sessionStorage.getItem(LS_KEY) === 'true';
    if (!ok) showGate();
  });

  confirmBtn?.addEventListener('click', () => {
    const remember = !!rememberCb?.checked;
    (remember ? localStorage : sessionStorage).setItem(LS_KEY, 'true');
    hideGate();
  });
})();
(function(){
  const KEY = 'kk_vp_help_hidden';
  const el  = document.getElementById('vpHow');
  if (!el) return;
  if (localStorage.getItem(KEY) === '1') el.hidden = true;
  el.querySelector('.close')?.addEventListener('click', () => {
    el.hidden = true; localStorage.setItem(KEY, '1');
  });
})();
</script>
<script type="module">
  import { placeBet } from "/assets/walletBet.bundle.js?v=20250303";
  window.placeBet = placeBet;

  // 1. Setup CSRF Helper
  async function fetchCsrf() {
    const r = await fetch('/api/csrf', { credentials: 'include' });
    const j = await r.json();
    window.csrfToken = j.csrfToken;
    return j.csrfToken;
  }

  // 2. Setup Wallet Link Helper
  async function ensureLinked() {
    const r = await fetch('/api/wallet/status', { credentials: 'include' });
    const j = await r.json().catch(() => null);
    return j?.ok && j.linked ? j : null;
  }

  addEventListener('DOMContentLoaded', async () => {
    await fetchCsrf(); // Init security token
    
    // Check wallet connection
    const linked = await ensureLinked();
    const betBtn = document.getElementById('betBtn');
    const drawBtn = document.getElementById('draw');

    // Setup initial button states
    if (betBtn) {
      betBtn.disabled = !linked;
      betBtn.textContent = 'Place 10 KIBL Bet';
    }
    if (drawBtn) drawBtn.disabled = true; // Can't draw until we deal

    if (linked?.address) {
      window.loadWalletBalances?.(linked.address);
    }

    // --- SINGLE CLICK HANDLER FOR BETTING ---
    betBtn?.addEventListener('click', async () => {
      if (betBtn.disabled || betBtn.classList.contains('busy')) return;

      try {
        if (!linked) return alert('Link a wallet on the Connect page first.');

        // Lock UI
        betBtn.classList.add('busy');
        betBtn.textContent = 'Signing...';
        betBtn.disabled = true;

        const passphrase = prompt('Enter your wallet passphrase to sign the bet:') || '';
        if (!passphrase) throw new Error('Cancelled');

        // 1. Send the Crypto (The "Fee")
        const { txId } = await placeBet({
          passphrase,
          kiblAmount: 10000, 
          tokenIdHex: window.KIBL_TOKEN_ID_HEX,
          feeNexa: 600
        });

        toast(`Bet sent! Transaction: ${txId.slice(0, 8)}‚Ä¶`, { type: 'win' });
        
        // 2. Start the Game Logic (The "Deal")
        betBtn.textContent = 'Dealing...';
        
        // We call the existing startGame() function you have defined globally
        // This triggers /api/start-hand and /api/deal
        await window.startGame(); 

        // 3. Update UI for the "Draw" phase
        betBtn.style.display = 'none'; // Hide bet button during the hand
        drawBtn.disabled = false;      // Enable draw button
        
        // Refresh wallet balances
        loadProfile();
        if (linked?.address) loadWalletBalances(linked.address);

      } catch (e) {
        if (e.message !== 'Cancelled') {
          toast(`Bet failed: ${e.message}`, { type: 'error' });
          betBtn.disabled = false;
          betBtn.textContent = 'Place 10 KIBL Bet';
        } else {
          betBtn.disabled = false;
          betBtn.textContent = 'Place 10 KIBL Bet';
        }
      } finally {
        betBtn.classList.remove('busy');
      }
    });

    // --- HOOK INTO DRAW TO RESET ---
    // We need to bring the Bet button back after the hand is over.
    // Since draw() is global, we can attach a listener to the draw button
    // to verify when it's done, or simpler: modify the global draw() to reset UI.
    // For now, let's use a MutationObserver to see when draw disables itself.
    const obs = new MutationObserver((mutations) => {
      mutations.forEach((m) => {
        if (m.attributeName === 'disabled' && drawBtn.disabled === true) {
          // If draw became disabled, the hand is likely over. Show bet button again.
          // Small delay to let the win animation play
          setTimeout(() => {
             betBtn.style.display = 'inline-flex';
             betBtn.disabled = false;
             betBtn.textContent = 'Place 10 KIBL Bet';
          }, 2000);
        }
      });
    });
    obs.observe(drawBtn, { attributes: true });
  });
</script>
<footer style="opacity:.9;color:var(--text-dim);font-size:12px;text-align:center;padding:14px 0 6px;">
  ¬© 2025 KIBL / PixelPup ‚Ä¢ Stay shiny üê∂‚ú® ‚Ä¢
  <a href="tos.html">Terms</a> ‚Ä¢ <a href="privacy.html">Privacy</a> ‚Ä¢ <a href="disclaimer.html">Disclaimer</a>
</footer>
</body>
</html>
